#!/usr/bin/env python

from __future__ import division
import numpy as np
import pandas as pd
# TODO figure out what the hold up is on importing this, with the prints
import multi_tracker_analysis as mta
import glob
from os.path import join, split
import os
import re
import pickle
from stimuli.srv import LoadSequenceRequest
# TODO maybe remove this dependency if it means it cant be run easily on windows?
import rosparam

import sys

# TODO replace rosparam usage w/ this?
# using this rather than pyyaml, because this supports rejecting duplicate keys
from ruamel import yaml

# TODO check current dir -> check for env var -> check that dir
# what all indications of having data from this kind of experiment?
# not sure i want to make config file mandatory

verbose = False

# TODO flag to just show interactive plot?

only_show_interactive = False
show_plots = True
save_plots = True
plot_format = 'png'
make_plots = show_plots or save_plots

want_time_spent = True
want_preference_index = False
# TODO turn off interactive plots if this is false? rename interactive flag?
display_metrics = want_time_spent or want_prefence_index 

# TODO also include option to color lines in metric change plots by same labels?
show_experiment_labels = True

if make_plots:
    import matplotlib.pyplot as plt
    import matplotlib.patches as patches
    import seaborn as sns
    #from matplotlib import rcParams
    #rcParams.update({'figure.autolayout': True})
    # was it set_style?
    sns.set_style('white')

# TODO load
left_shock = 6
right_shock = 5

def load_metadata(d):
    files = glob.glob(join(d, '*_stimuli.p'))
    if len(files) > 1:
        raise IOError('too many stimulus files in ' + d)
    elif len(files) < 1:
        raise IOError('found no stimulus files in ' + d)
    filename = files[0]
    with open(filename, 'rb') as f:
        # TODO it seems like pins2odors would really be more useful?
        odors2left_pins, odors2right_pins, _, trial_structure = pickle.load(f)
    times = dict()
    times['start'] = trial_structure[0].to_sec()
    times['end'] = trial_structure[-1].to_sec()
    stimuli = filter(lambda x: type(x) is LoadSequenceRequest, trial_structure)
    times['pretest_start'] = stimuli[0].seq.start.to_sec()
    times['posttest_start'] = stimuli[-1].seq.start.to_sec()
    times['test_duration'] = stimuli[0].seq.end.to_sec() - stimuli[0].seq.start.to_sec()

    # TODO load
    left_pins = [56, 57, 59]
    right_pins = [54, 55, 61]

    # TODO check
    def pin_from(check, group):
        pins = [p for p in check if p in group]
        assert len(pins) == 1
        return pins[0]

    def odor_for_pin(odors2pins, pin):
        odors = [o for o, p in odors2pins.items() if p == pin]
        assert len(odors) == 1
        return odors[0]

    def prepost_odors(odors2pins, pin_group, stimuli):
        prepins = stimuli[0].seq.pins
        postpins = stimuli[-1].seq.pins
        prepin = pin_from(prepins, pin_group)
        postpin = pin_from(postpins, pin_group)
        return odor_for_pin(odors2pins, prepin), odor_for_pin(odors2pins, postpin)

    pretest_left_odor, posttest_left_odor = prepost_odors(odors2left_pins, left_pins, stimuli)
    pretest_right_odor, posttest_right_odor = prepost_odors(odors2right_pins, right_pins, stimuli)

    # TODO check that all blocks would yield the same answer
    for block in stimuli[1:-1]:
        odors = []
        if left_shock in block.seq.pins:
            odors += [o for o, p in odors2left_pins.items() if p in block.seq.pins]
        if right_shock in block.seq.pins:
            odors += [o for o, p in odors2right_pins.items() if p in block.seq.pins]
        # TODO check
        odors = set(odors)
        if len(odors) > 0:
            assert len(odors) == 1
            reinforced_odor = odors.pop()
            break

    metadata = dict()
    metadata['times'] = times
    metadata['pretest_left_odor'] = pretest_left_odor
    metadata['posttest_left_odor'] = posttest_left_odor
    metadata['pretest_right_odor'] = pretest_right_odor
    metadata['posttest_right_odor'] = posttest_right_odor
    # TODO check
    metadata['reinforced_odor'] = reinforced_odor
    '''
    if split(d)[-1] == '20170919_090747':
        print ''
        print 'trial_structure', trial_structure
        print 'experiment:', split(d)[-1]
        print 'odors2left_pins:', odors2left_pins
        print 'odors2right_pins:', odors2right_pins
        print 'pretest left:', odors2left_pins[pretest_left_odor], pretest_left_odor 
        print 'posttest left:', odors2left_pins[posttest_left_odor], posttest_left_odor 
        print 'pretest right:', odors2right_pins[pretest_right_odor], pretest_right_odor 
        print 'posttest right:', odors2right_pins[posttest_right_odor], posttest_right_odor 
        print 'reinforced odor', reinforced_odor
        print ''
        print ''
    '''
    metadata['stimuli'] = list(stimuli)
    # TODO switch to new style
    left_pins2odors = dict((v, k) for k, v in odors2left_pins.items())
    right_pins2odors = dict((v, k) for k, v in odors2right_pins.items())

    assert len(left_pins2odors) == len(odors2left_pins), 'some odors map to multiple left pins'
    assert len(right_pins2odors) == len(odors2right_pins), 'some odors map to multiple right pins'

    # TODO check
    for p in left_pins2odors.keys():
        assert not p in right_pins2odors.keys(), 'pin ' + str(p) + \
            ' was listed as both left and right'
    for p in right_pins2odors.keys():
        assert not p in left_pins2odors.keys(), 'pin ' + str(p) + \
            ' was listed as both left and right'

    metadata['left_pins2odors'] = left_pins2odors
    metadata['right_pins2odors'] = right_pins2odors
    metadata['odors'] = set(odors2left_pins.keys()) | set(odors2right_pins.keys())
    return metadata

# TODO allow script to be run in directory w/ data
path = '/home/tom/data/retracked'
# TODO just walk from path in future?
# or glob on date here and glob separately below?

#dirs = ['20170913_104724', '20170913_105853', '20170913_112951']
# TODO regex matching this timestamp pattern?
# TODO use original timestamp flag when retracking
#dirs = glob.glob('/home/tom/data/retracked/20170919*')
dirs = glob.glob('/home/tom/data/retracked/2017091*')

# TODO flag to visually indicate which indices are counted for the various preference metrics

# TODO maybe have a flag to save figures for rejects?
reject_bad = True

with open(join(path, 'analysis_rejects.yaml'), 'r') as f:
    yaml_loader = yaml.YAML()
    yaml_loader.allow_duplicate_keys = False
    rejects = yaml_loader.load(f)

bad = dict()
for reason, reject_dict in rejects.items():
    if reject_dict is None:
        continue

    for exp_id, rois in reject_dict.items():
        if exp_id in bad:
            bad[exp_id] = bad[exp_id] | set(rois)
        else:
            bad[exp_id] = set(rois)

curr_fly = 0
fly2data = dict()
fly2meta = dict()
all_odors = set()

experiment2label = dict()
curr_char = ord('A')

for d in map(lambda x: join(path, x), dirs):
    # TODO check trial structure times against those in log
    common_metadata = load_metadata(d)
    for o in common_metadata['odors']:
        all_odors.add(o)

    # TODO can join take a variable # of args?
    for f in glob.glob(join(d, '*.hdf5')):
        metadata = dict(common_metadata)
        # TODO make it so this generates the (optional) config? notify if doing so
        # TODO TODO exclude trajectories that don't cover enough ground
        data, _ = mta.read_hdf5_file_to_pandas.load_and_preprocess_data(f)
        '''
        print 'position_x range', data['position_x'].min(), data['position_x'].max()
        print 'position_y range', data['position_y'].min(), data['position_y'].max()
        '''
        match = re.search('_N([0-9])_', f)
        # TODO why is it more than what is in the parens?
        #print 'MATCH', match
        metadata['n'] = int(match.group(0)[2:-1])

        stamp = split(d)[-1]
        '''
        if reject_bad and metadata['n'] in bad[stamp]:
            if verbose:
                print 'skipping fly', metadata['n'], 'from experiment', stamp, 'because listed as bad'
            continue
        '''

        fly2data[curr_fly] = data
        metadata['dir'] = d

        if d not in experiment2label:
            experiment2label[d] = chr(curr_char)
            curr_char += 1

        roi_points = rosparam.load_file(join(d, 'roi_N' + str(metadata['n']) + \
            '.yaml'))[0][0]['roi_points']
        metadata['roi_points'] = roi_points
        fly2meta[curr_fly] = metadata
        curr_fly += 1

if make_plots:
    # TODO seed or something for better colors w/ # odors=2
    cmap = sns.color_palette('husl', len(all_odors))
    odor2color = dict()
    for o, c in zip(all_odors, cmap):
        odor2color[o] = c


def analyze_group(fly2data, title=''):
    """
    """
    y_maxes_above_mid = []
    y_mins_below_mid = []

    # TODO assert that we are analyzing with dimension that corresponds to long axis of roi

    for m in fly2meta.values():
        y_vals = map(lambda p: p[1], m['roi_points'])
        curr_mid = np.mean(y_vals)
        centered_y_vals = map(lambda y: y - curr_mid, y_vals)
        y_maxes_above_mid.append(max(centered_y_vals))
        y_mins_below_mid.append(min(centered_y_vals))

    y_max_above_mid = max(y_maxes_above_mid)
    y_min_below_mid = min(y_mins_below_mid)

    if verbose:
        print 'y_min_below_mid', y_min_below_mid, 'y_max_above_mid', y_max_above_mid

    # TODO divide into mch and oct? make a dataframe including all variables (like side, etc)?
    percent_reinforced_pre = []
    percent_reinforced_post = []

    # TODO why did 1100 not work? isn't sequence 1000 long?
    crop_to_seconds = 1300

    # TODO line up images of ROIs, with drawn midline, to check for those errors
    # TODO label / group by the reinforced odor?

    plotting_y_max = None
    plotting_y_min = None
    plotting_x_max = None
    plotting_x_min = None

    axes_to_set_limits = []
    fly_nums_in_order = []

    y_shock_to_odor = 2
    y_beyond_arena = 0
    small_height = 4
    odor_patch_alpha = 0.4
    shock_patch_alpha = 0.8
    shock_color = 'red'

    if make_plots:
        label_set = set()
        labels = []
        handles = []

        scale = 12
        fig, axes = plt.subplots(nrows=len(fly2data), sharex=True, sharey=True, \
            squeeze=True, figsize=(scale * 1, scale * 1))
        if not type(axes) is np.ndarray:
            axes = [axes]

        plt.xlabel('Seconds')

    curr_ax = 0
    for fly, data in fly2data.items():
        meta = fly2meta[fly]
        # TODO what happens to missing data?
        # plotted as zero? not plotted?
        curr_times = (data['time_epoch_secs'] + data['time_epoch_nsecs'] / 1e9).as_matrix()
        # TODO so does floris initialize something to 5000? blocks written in that size?
        #print(curr_times.shape)
        nonzero_times = curr_times.nonzero()[0]
        if nonzero_times.size == 0:
            # TODO automatically add these to yaml? recommend?
            # count earlier to get the right # of subplots?
            if verbose:
                print 'SKIPPING FLY', meta['n'], 'FROM', meta['dir']
            continue

        if verbose:
            print 'fly', meta['n'], 'from', meta['dir']
        #start = curr_times[nonzero_times].min()
        start = meta['times']['pretest_start'] - 60

        # TODO print how much this fly has walked (in each test period?)

        #print 'START TIME =', start
        #print '# of zero entries', curr_times.size - nonzero_times.size

        # because for some of these, the tracking ran much longer than the stimulus presentation
        cropped_indices = (curr_times - start) <= crop_to_seconds
        cropped_times = curr_times[cropped_indices]
        # relative to start of experiment
        cropped_rel_times = cropped_times - start

        # calculate percent time in each odor region
        # TODO make one variable at top which controls which dimension to use as long axis
        # and have this (and elsewhere) depend on that
        y_mid = np.mean(map(lambda x: x[1], meta['roi_points']))
        if make_plots:
            # TODO TODO filter very high frequency noise out before plotting
            # multiplied by negative one so it is displayed in same orientation as video
            # and also by patches (rectangles) indicating which side each odor is on
            # TODO maybe try antialiased=True/False? default?
            # rasterized default?
            ax = axes[curr_ax]
            curr_ax += 1
            ax.plot(cropped_rel_times , (-1) * (data['position_y'][cropped_indices] - y_mid), \
                c='black', linewidth=1.3)

        y_max = max(map(lambda x: x[1], meta['roi_points']))
        y_min = min(map(lambda x: x[1], meta['roi_points']))
        if verbose:
            print 'y_max', y_max, 'y_min', y_min, 'using y midline', y_mid
        left = data['position_y'][cropped_indices] > y_mid
        # TODO maybe use times from log, rather than these?
        pretest_indices = np.logical_and(cropped_times > meta['times']['pretest_start'], \
            cropped_times < (meta['times']['pretest_start'] + \
            meta['times']['test_duration']))

        posttest_indices = np.logical_and(cropped_times > meta['times']['posttest_start'], \
            cropped_times < (meta['times']['posttest_start'] + \
            meta['times']['test_duration']))

        # TODO TODO filter out trajectories that don't move much. 
        # just use floris' config file thing?

        large_height = (y_max_above_mid - y_min_below_mid) / 2 + y_beyond_arena
        
        for i, s in enumerate(meta['stimuli']):
            width = (s.seq.end - s.seq.start).to_sec()
            for p in s.seq.pins:
                color = 'b'
                label = None
                if p is left_shock:
                    label = 'shock'
                    color = shock_color
                    height = small_height
                    y0 = y_min_below_mid - y_beyond_arena - (y_shock_to_odor + small_height)
                    alpha = shock_patch_alpha

                elif p is right_shock:
                    label = 'shock'
                    color = shock_color
                    height = small_height
                    y0 = y_max_above_mid + y_beyond_arena + y_shock_to_odor
                    alpha = shock_patch_alpha

                # TODO i think the reason these have been displaying correctly is that
                # y_min_below_mid ~= y_max_above_mid, though those are probably still
                # calculated for the wrong sides. fix? use one number equal to their average?

                # displayed on down side in plot, and down should also be left in the video
                # , with closer arenas further to the right
                elif p in meta['left_pins2odors']:
                    #print 'left odor', meta['left_pins2odors'][p]
                    if make_plots:
                        label = meta['left_pins2odors'][p]
                        color = odor2color[label]
                    y0 = y_min_below_mid - y_beyond_arena
                    height = large_height
                    alpha = odor_patch_alpha

                # displayed on top sides of plots, which should also be right in the video
                elif p in meta['right_pins2odors']:
                    #print 'right odor', meta['right_pins2odors'][p]
                    if make_plots:
                        label = meta['right_pins2odors'][p]
                        color = odor2color[label]
                    # because we define the middle as the new origin
                    y0 = 0
                    height = large_height
                    alpha = odor_patch_alpha

                else:
                    #print 'skipping pin', p
                    continue

                # TODO maybe subdivide for shocks? (to reflect actual pulse cycle ~2.5s on/off)
                x0 = s.seq.start.to_sec() - start
                #print 'seq.start.to_sec()', s.seq.start.to_sec(), 'x0', x0, 'width', width
                if i == 0:
                    # define acceptable mismatch here?
                    if x0 <= 0.0:
                        if verbose:
                            print 'WARNING! seems no video was recorded for first ' + \
                                str(-x0) + ' seconds of first block (pre-training test)'

                else:
                    assert x0 > 0, 'times we want to disply should not be negative. was ' + str(x0)

                assert x0 + width < crop_to_seconds, 'last time index of patched ' + \
                    'region should fall within limits of cropped experiment. was ' + \
                    str(x0 + width) + ' end=' + str(crop_to_seconds)
                #print 'patching pin', p, 'from', (x0, y0), 'with w=', width, 'and h=', height

                if make_plots:
                    p = patches.Rectangle((x0, y0), width, height, alpha=alpha, \
                        facecolor=color, edgecolor=color)
                    ax.add_patch(p)

                    if (not label is None)  and (not label in label_set):
                        label_set.add(label)
                        labels.append(label)
                        handles.append(p)

                    curr_y_max = y0 + height
                    if plotting_y_max is None or plotting_y_max < curr_y_max:
                        plotting_y_max = curr_y_max

                    curr_y_min = y0
                    if plotting_y_min is None or plotting_y_min > curr_y_min:
                        plotting_y_min = curr_y_min

                    curr_x_max = x0 + width
                    if plotting_x_max is None or plotting_x_max < curr_x_max:
                        plotting_x_max = curr_x_max

                    curr_x_min = x0
                    if plotting_x_min is None or plotting_x_min > curr_x_min:
                        plotting_x_min = curr_x_min

        assert pretest_indices.dtype == np.bool, \
            'later functions assume indices represented as boolean mask'
        assert posttest_indices.dtype == np.bool, \
            'later functions assume indices represented as boolean mask'
        assert not np.any(np.logical_and(pretest_indices, posttest_indices)), \
            'pre and post test indices overlapped'
        # maybe allow some tolerance here
        assert pretest_indices.size == posttest_indices.size

        # TODO warn whenever different
        n_pretest_indices = np.sum(pretest_indices)
        n_posttest_indices = np.sum(posttest_indices)
        curr_rel_err = abs(n_pretest_indices - n_posttest_indices) / n_posttest_indices
        '''
        rel_indices_tol = 0.35
        assert curr_rel_err <= rel_indices_tol, '# pretest_indices=' + \
            str(n_pretest_indices) + ', # posttest_indices=' + str(n_posttest_indices) + \
            ', relative error=' + str(curr_rel_err)
        '''
        if curr_rel_err != 0:
            if verbose:
                print 'WARNING! relative difference in timepoints in pre and post test = ' + \
                    str(curr_rel_err)

        # TODO TODO factor into function for better consistency / isolation
        # TODO include a buffer region that is called in neither direction 
        # to make this more robust to misspecifying the middle of the arena?
        # TODO check uniform sampling rate?
        percent_left_pre = np.sum(left[pretest_indices]) / np.sum(pretest_indices)
        #print 'sum pretest indices on left', np.sum(left[pretest_indices])
        #print 'sum pretest_indices', np.sum(pretest_indices)
        if meta['reinforced_odor'] == meta['pretest_left_odor']:
            percent_reinforced_pre.append(percent_left_pre)
            if verbose:
                print('pretest_left_odor was reinforced')
        elif meta['reinforced_odor'] == meta['pretest_right_odor']:
            percent_reinforced_pre.append(1 - percent_left_pre)
            if verbose:
                print('pretest_left_odor was NOT reinforced')
        else:
            assert False, 'neither of pretest_<left/right>_odor(s) were equal to reinforced odor'

        percent_left_post = np.sum(left[posttest_indices]) / np.sum(posttest_indices)
        #print 'sum posttest indices on left', np.sum(left[posttest_indices])
        #print 'sum posttest_indices', np.sum(posttest_indices)
        if meta['reinforced_odor'] == meta['posttest_left_odor']:
            percent_reinforced_post.append(percent_left_post)
            if verbose:
                print('posttest_left_odor was reinforced')
        elif meta['reinforced_odor'] == meta['posttest_right_odor']:
            percent_reinforced_post.append(1 - percent_left_post)
            if verbose:
                print('posttest_left_odor was NOT reinforced')
        else:
            assert False, 'neither of posttest_<left/right>_odor(s) were equal to reinforced odor'
        # TODO save these into something easily loadable as pandas dataframe?
        # w/ other metadata i might want

        # TODO calculate other metric

        # TODO only print metrics if not make_plots and display_metrics? just latter?
        if make_plots:
            if display_metrics:
                # TODO other metrics?
                text = ''
                if want_time_spent:
                    # TODO make robust to fly #0 getting skipped
                    if fly == 0:
                        text += 'pre: %.3f in reinforced\npost: %.3f in reinforced' % \
                            (percent_reinforced_pre[-1], percent_reinforced_post[-1])
                    else:
                        text += 'pre: %.3f\npost: %.3f' % \
                            (percent_reinforced_pre[-1], percent_reinforced_post[-1])

                # TODO might want this to the left of the other (not above / below)?
                if want_preference_index:
                    # TODO was it performance index or preference index?
                    # TODO nicer way to do this? join list w/ newline?
                    if want_time_spent:
                        text += '\n'

                    text += 'PI pre: %.3f\nPI post: %.3f' % \
                        (pre_preference_index[-1], post_prefence_index[-1])

                # no sure i want a box?
                # TODO what does verticalalignment do?
                ax.text(1, 0.7, text, transform=ax.transAxes, fontsize=8, \
                    verticalalignment='top')

                # different name for this flag?
                if show_experiment_labels:
                    ax.text(-.04, 0.6, experiment2label[meta['dir']], \
                        transform=ax.transAxes, fontsize=12, verticalalignment='top')

            axes_to_set_limits.append(ax)
            fly_nums_in_order.append(fly)

    if make_plots:
        fig.legend(handles=handles, labels=labels, loc='lower left', fontsize=9)

    if verbose:
        print 'plotting ranges: x', (plotting_x_min, plotting_x_max), 'y', \
            (plotting_y_min, plotting_y_max)

    # relative
    y_bord = 0.025
    x_bord = 0.025
    x_range = plotting_x_max - plotting_y_min
    y_range = plotting_y_max - plotting_y_min
    plotting_x_min = plotting_x_min - x_range * x_bord
    plotting_x_max = plotting_x_max + x_range * x_bord
    plotting_y_min = plotting_y_min - y_range * y_bord
    plotting_y_max = plotting_y_max + y_range * y_bord

    for fly, ax in zip(fly_nums_in_order, axes_to_set_limits):
        ax.set_xlim([plotting_x_min, plotting_x_max])
        ax.set_ylim([plotting_y_min, plotting_y_max])
        if fly != len(fly_nums_in_order) - 1:
            ax.axis('off')
        else:
            ax.spines['top'].set_visible(False)
            ax.spines['right'].set_visible(False)
            ax.spines['left'].set_visible(False)
            # TODO make the bottom frame a little further away
            #print 'xticks:', ax.get_xticks()
            ax.set_yticks([])
            # TODO why was this not working?
            #ax.tick_params(axis='x', direction='out')

    if save_plots:
        # TODO flag to output all figs in current dir? (as well?) symlink?
        if title == '':
            fig.savefig('traces.' + plot_format)

        else:
            plt.suptitle(title)
            fig.savefig(title.replace(' ', '_') + '_traces.' + plot_format)

    if (not show_plots) or only_show_interactive:
        plt.close('all')

    # TODO maybe have this function return the results of the loop above, 
    # optionally making plots of traces?
    # how best to break it up?

    # TODO make it so you can get fly id from hovering? or clicking?
    # TODO patch in counted regions for troubleshooting?
    if make_plots:
        fig = plt.figure(figsize=(4,4))
        plt.title('Conditioned change in preference')
        plt.ylabel('Proportion of test spent in shocked odor')
        x = [0, 1]
        plt.xticks(x, ['Pre', 'Post'])
        ax = plt.gca()
        ax.set_xlim([-.2, 1.2])
        ax.set_ylim([-.1, 1.1])

        for fly, pre, post in zip(fly_nums_in_order, \
                percent_reinforced_pre, percent_reinforced_post):

            label = split(fly2meta[fly]['dir'])[-1] + ', ROI ' + str(fly2meta[fly]['n'])
            ax.plot(x, [pre, post], marker='.', label=label, color='black')

        # TODO boxplot on top of this?
        if save_plots:
            # TODO save at same level as all experiment directories?
            if title == '':
                fig.savefig('preference_change.' + plot_format, bbox_inches='tight')
            else:
                fig.savefig(title.replace(' ', '_') + '_preference_change.' + plot_format, bbox_inches='tight')

        if show_plots:
            def on_plot_hover(ax, event):
                on_any_curve = False
                for curve in ax.get_lines():
                    if curve.contains(event)[0]:
                        on_any_curve = True
                        # drawing at one side would probably also be acceptable
                        # rectangular patch as relief, behind text?
                        if not hasattr(on_plot_hover, 'text_handle'):
                            on_plot_hover.text_handle = ax.text(float(event.xdata), \
                                    float(event.ydata), curve.get_label())

                        else:
                            on_plot_hover.text_handle.set_x(float(event.xdata))
                            on_plot_hover.text_handle.set_y(float(event.ydata))
                            on_plot_hover.text_handle.set_text(curve.get_label())
                        on_plot_hover.text_handle.set_visible(True)

                if (not on_any_curve) and hasattr(on_plot_hover, 'text_handle'):
                    on_plot_hover.text_handle.set_visible(False)

                ax.figure.canvas.draw_idle()

            fig.canvas.mpl_connect('motion_notify_event', lambda e: on_plot_hover(ax, e)) 
            plt.show()

        else:
            plt.close('all')

    return percent_reinforced_pre, percent_reinforced_post

good_fly2data = dict()
for k, v in fly2data.items():
    stamp = split(fly2meta[k]['dir'])[-1]

    if not stamp in bad:
        good_fly2data[k] = v
    elif not fly2meta[k]['n'] in bad[stamp]:
        good_fly2data[k] = v
    
#analyze_group(good_fly2data)

for reason, reject_dict in rejects.items():
    if reject_dict is None:
        continue

    bad_fly2data = {k: v for k, v in fly2data.items() \
        if split(fly2meta[k]['dir'])[-1] in reject_dict and \
        fly2meta[k]['n'] in reject_dict[split(fly2meta[k]['dir'])[-1]]}

    if reason == 'no_fly':
        print len(bad_fly2data), 'rois marked as not having a fly in them. not analyzing them.'
        continue

    print reason
    print '# of this reject type', len(bad_fly2data)
    analyze_group(bad_fly2data, title=reason.replace('_', ' '))
